# mipt-flat-2020-practice1

Вариант 6: Даны α, буква x и натуральное число k. Вывести, есть ли в языке L слова,
содержащие ровно k букв x.



##### Идея алгоритма
Будем делить выражения на операнды каждого знака из {., *, +} и рекурсивно проверять, возможно ли частью выражения задать слово с данным числов букв x. Изначально искомое количество равно k. При встрече точки проверить все возможные разбиения k на сумму двух чисел k1, k2 (проверяем, что в одном из операндов может быть k1 искомых букв в слове, а в другом - k2; если оба условия выполнятся, то полученным задается в том числе и слово с k буквами x). При нахождении плюса достаточно проверить, что в слове, заданном хотя бы одним из операндов, может быть k искомых букв. Для звездочки надо проверить все делители k, включая 1 и само k, т.к. количество букв в выражении под ним можно домножить на любое натуральное число. В конце концов операндами окажутся отдельные символы алфавита, которые просто проверяем на совпадение с искомой. 

##### Оценка сложности
Деление одного выражения на два работает за O(N^2), где N - длина данного ему выражения.
Пусть проверка, может ли быть k букв, работает за T(N, k). 
T(N,k) = N^2 + k(T(N1, k1) + T(N2, k2)), если оператор - точка
T(N, k) = N^2 + T(N1, k) + T(N2, k), если плюс
T(N, k) = sqrt(k) + KT(N-1, k//div), где K - число делителей k, если звездочка
Каждый раз длина рассматриваемого выражения уменьшается хотя бы на один, поэтому в худшем случае T(N, k) будет примерно N^2 + 2kT(N-1) (для точки с верхней оценкой N1,N2 <= N-1), то есть суммарное время работы будет O(N^3 * (2k)^N). Но оценки сверху везде берутся довольно-таки грубые, так что на практике должно быть получше.



